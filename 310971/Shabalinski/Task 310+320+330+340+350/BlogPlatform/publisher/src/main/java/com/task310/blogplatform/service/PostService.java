package com.task310.blogplatform.service;

import com.task310.blogplatform.dto.PostRequestTo;
import com.task310.blogplatform.dto.PostResponseTo;
import com.task310.blogplatform.dto.kafka.PostKafkaRequest;
import com.task310.blogplatform.exception.EntityNotFoundException;
import com.task310.blogplatform.exception.ValidationException;
import com.task310.blogplatform.repository.ArticleRepository;
import com.task310.blogplatform.service.kafka.PostKafkaConsumer;
import com.task310.blogplatform.service.kafka.PostKafkaProducer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientException;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Caching;

import java.util.List;
import java.util.concurrent.TimeUnit;

@Service
public class PostService {
    private final WebClient discussionWebClient;
    private final ArticleRepository articleRepository;
    private final PostKafkaProducer kafkaProducer;
    private final PostKafkaConsumer kafkaConsumer;

    @Autowired
    public PostService(@Qualifier("discussionWebClient") WebClient discussionWebClient, 
                      ArticleRepository articleRepository,
                      PostKafkaProducer kafkaProducer,
                      PostKafkaConsumer kafkaConsumer) {
        this.discussionWebClient = discussionWebClient;
        this.articleRepository = articleRepository;
        this.kafkaProducer = kafkaProducer;
        this.kafkaConsumer = kafkaConsumer;
    }

    @Caching(evict = {
        @CacheEvict(value = "posts", allEntries = true),
        @CacheEvict(value = "postsByArticle", allEntries = true)
    })
    public PostResponseTo create(PostRequestTo dto) {
        validatePostRequest(dto);
        
        // Validate article exists
        if (dto.getArticleId() != null) {
            if (!articleRepository.existsById(dto.getArticleId())) {
                throw new EntityNotFoundException("Article not found with id: " + dto.getArticleId());
            }
        }
        
        // Create Kafka request (ID will be generated by discussion service)
        PostKafkaRequest kafkaRequest = new PostKafkaRequest();
        kafkaRequest.setId(null); // Let discussion service generate ID
        kafkaRequest.setArticleId(dto.getArticleId());
        kafkaRequest.setContent(dto.getContent());
        
        // Send to Kafka
        kafkaProducer.sendPostRequest(kafkaRequest);
        
        // Wait for response from Kafka (with timeout)
        // We'll check for any new response since we don't know the ID in advance
        PostResponseTo response = null;
        int maxAttempts = 20; // 20 seconds timeout (increased to allow more time)
        long startTime = System.currentTimeMillis();
        org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(PostService.class);
        logger.info("Waiting for Kafka response for articleId={}, startTime={}", dto.getArticleId(), startTime);
        for (int i = 0; i < maxAttempts; i++) {
            try {
                Thread.sleep(500); // Wait 500ms
                // Check for any response that matches our articleId and was created recently
                // This is a simplified approach - in production, use correlation IDs
                long checkTimestamp = startTime - 2000; // Allow 2 seconds before start time
                response = kafkaConsumer.getLatestResponseForArticle(dto.getArticleId(), checkTimestamp);
                if (response != null) {
                    logger.info("Received response for articleId={} after {} attempts", dto.getArticleId(), i + 1);
                    break;
                }
                if ((i + 1) % 4 == 0) { // Log every 2 seconds
                    logger.debug("Still waiting for response for articleId={}, attempt {}/{}", dto.getArticleId(), i + 1, maxAttempts);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Interrupted while waiting for Kafka response", e);
            }
        }
        
        if (response == null) {
            throw new RuntimeException("Timeout waiting for post creation response from discussion service. Please ensure the discussion module is running and processing Kafka messages.");
        }
        
        return response;
    }

    @Cacheable(value = "posts", key = "'all'")
    public List<PostResponseTo> findAll() {
        try {
            return discussionWebClient.get()
                    .uri("/api/v1.0/posts")
                    .retrieve()
                    .bodyToMono(new ParameterizedTypeReference<List<PostResponseTo>>() {})
                    .block();
        } catch (WebClientResponseException e) {
            throw new RuntimeException("Error fetching posts: " + e.getMessage(), e);
        } catch (WebClientException e) {
            throw e; // Re-throw to be handled by GlobalExceptionHandler
        }
    }

    @Cacheable(value = "posts", key = "#id")
    public PostResponseTo findById(Long id) {
        if (id == null || id <= 0) {
            throw new ValidationException("Invalid post id");
        }
        try {
            return discussionWebClient.get()
                    .uri("/api/v1.0/posts/{id}", id)
                    .retrieve()
                    .bodyToMono(PostResponseTo.class)
                    .block();
        } catch (WebClientResponseException e) {
            if (e.getStatusCode() == HttpStatus.NOT_FOUND) {
                throw new EntityNotFoundException("Post not found with id: " + id);
            }
            throw new RuntimeException("Error fetching post: " + e.getMessage(), e);
        } catch (WebClientException e) {
            throw e; // Re-throw to be handled by GlobalExceptionHandler
        }
    }

    @Caching(evict = {
        @CacheEvict(value = "posts", key = "#id"),
        @CacheEvict(value = "posts", key = "'all'"),
        @CacheEvict(value = "postsByArticle", key = "#dto.articleId"),
        @CacheEvict(value = "postsByArticle", allEntries = true)
    })
    public PostResponseTo update(Long id, PostRequestTo dto) {
        if (id == null || id <= 0) {
            throw new ValidationException("Invalid post id");
        }
        validatePostRequest(dto);
        
        // Validate article exists
        if (dto.getArticleId() != null) {
            if (!articleRepository.existsById(dto.getArticleId())) {
                throw new EntityNotFoundException("Article not found with id: " + dto.getArticleId());
            }
        }
        
        try {
            return discussionWebClient.put()
                    .uri("/api/v1.0/posts/{id}", id)
                    .contentType(MediaType.APPLICATION_JSON)
                    .bodyValue(dto)
                    .retrieve()
                    .bodyToMono(PostResponseTo.class)
                    .block();
        } catch (WebClientResponseException e) {
            if (e.getStatusCode() == HttpStatus.NOT_FOUND) {
                throw new EntityNotFoundException("Post not found with id: " + id);
            }
            throw new RuntimeException("Error updating post: " + e.getMessage(), e);
        } catch (WebClientException e) {
            throw e; // Re-throw to be handled by GlobalExceptionHandler
        }
    }

    @Caching(evict = {
        @CacheEvict(value = "posts", key = "#id"),
        @CacheEvict(value = "posts", key = "'all'"),
        @CacheEvict(value = "postsByArticle", allEntries = true)
    })
    public void delete(Long id) {
        if (id == null || id <= 0) {
            throw new ValidationException("Invalid post id");
        }
        try {
            discussionWebClient.delete()
                    .uri("/api/v1.0/posts/{id}", id)
                    .retrieve()
                    .toBodilessEntity()
                    .block();
        } catch (WebClientResponseException e) {
            if (e.getStatusCode() == HttpStatus.NOT_FOUND) {
                throw new EntityNotFoundException("Post not found with id: " + id);
            }
            throw new RuntimeException("Error deleting post: " + e.getMessage(), e);
        } catch (WebClientException e) {
            throw e; // Re-throw to be handled by GlobalExceptionHandler
        }
    }

    @Cacheable(value = "postsByArticle", key = "#articleId")
    public List<PostResponseTo> getPostsByArticleId(Long articleId) {
        if (articleId == null || articleId <= 0) {
            throw new ValidationException("Invalid article id");
        }
        if (!articleRepository.existsById(articleId)) {
            throw new EntityNotFoundException("Article not found with id: " + articleId);
        }
        try {
            return discussionWebClient.get()
                    .uri("/api/v1.0/articles/{id}/posts", articleId)
                    .retrieve()
                    .bodyToMono(new ParameterizedTypeReference<List<PostResponseTo>>() {})
                    .block();
        } catch (WebClientResponseException e) {
            throw new RuntimeException("Error fetching posts by article id: " + e.getMessage(), e);
        } catch (WebClientException e) {
            throw e; // Re-throw to be handled by GlobalExceptionHandler
        }
    }

    private void validatePostRequest(PostRequestTo dto) {
        if (dto == null) {
            throw new ValidationException("Post data is required");
        }
        if (dto.getId() != null) {
            throw new ValidationException("Id must not be provided in request body");
        }
        if (dto.getContent() == null || dto.getContent().trim().isEmpty()) {
            throw new ValidationException("Content is required");
        }
        if (dto.getContent().trim().length() < 2) {
            throw new ValidationException("Content must be at least 2 characters long");
        }
        if (dto.getArticleId() == null || dto.getArticleId() <= 0) {
            throw new ValidationException("Valid articleId is required");
        }
    }
}
