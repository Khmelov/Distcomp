# HTTP Status Codes - Объяснение

## Проблема: Тесты ожидают 403, но получают 409

### Текущая реализация (ПРАВИЛЬНАЯ)

Для дубликатов ресурсов возвращается **409 CONFLICT**, что соответствует стандартам REST API:

- **Writer с дубликатом login** → `409 CONFLICT`
- **Tweet с дубликатом title** → `409 CONFLICT`
- **Label с дубликатом name** → `409 CONFLICT`

### HTTP Status Codes - Правильное использование

#### 403 FORBIDDEN
- **Использование:** Клиент не имеет прав доступа к ресурсу
- **Пример:** Пользователь пытается удалить чужой ресурс без прав
- **НЕ используется для:** Дубликатов ресурсов

#### 409 CONFLICT
- **Использование:** Запрос конфликтует с текущим состоянием сервера
- **Пример:** Попытка создать ресурс, который уже существует (дубликат)
- **Правильное использование для:** Дубликатов login, title, name и т.д.

### Почему 409, а не 403?

Согласно RFC 7231 (HTTP/1.1 Semantics and Content):
- **403 Forbidden** - "сервер понял запрос, но отказывается его авторизовать"
- **409 Conflict** - "запрос не может быть выполнен из-за конфликта с текущим состоянием ресурса"

Дубликат ресурса - это **конфликт состояния**, а не проблема авторизации.

### Рекомендация

**Обновите тесты**, чтобы они ожидали `409 CONFLICT` вместо `403 FORBIDDEN` для дубликатов:

```java
// Правильно
.then().statusCode(HttpStatus.CONFLICT.value()); // 409

// Неправильно
.then().statusCode(HttpStatus.FORBIDDEN.value()); // 403
```

### Если нужно изменить на 403 (НЕ РЕКОМЕНДУЕТСЯ)

Если по каким-то причинам требуется возвращать 403 для дубликатов (что противоречит стандартам), можно изменить `GlobalExceptionHandler`:

```java
@ExceptionHandler(ConflictException.class)
public ResponseEntity<ApiError> handleConflict(ConflictException ex) {
    return build(HttpStatus.FORBIDDEN, ex.getMessage(), "40301"); // НЕ РЕКОМЕНДУЕТСЯ
}
```

**Но это будет неправильно с точки зрения REST API best practices.**

